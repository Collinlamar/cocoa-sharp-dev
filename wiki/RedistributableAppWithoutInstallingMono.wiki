Summary: How to package up your Cocoa# / Mono app into a single .app file without requiring the end-user to install Mono.

NOTE: I did this with an SVN build of Cocoa#, and a fink (cvs'd) install of both mono and nant.  YMMV.

So.  You want to deploy your Cocoa#/Mono app to users, but you really don't want to make the user install Mono.  That's cool - I hate requiring runtime installs too.  Assuming you've got your application up and running fine on your development machine ( running it via the: "/usr/bin/mono myExec.exe" method ), it's time to package this bastard up.  

First things first, you want to make sure you have the mono tools mkbundle and macpack installed, as well as otool and install_name_tool, which should both be part of the OS X Developer's package ( I think - I don't have any machines w/o the dev tools, and I'm pretty damn tired of looking at references atm ). 

Before I continue, I should make a note: I'm going to be pasting how to accomplish the different steps with Nant tasks.  If you don't use Nant, I'm sorry, but it shouldn't be tough to accomplish your goals with whatever build process you use.

Got all the tools? Great.  Now the first thing you're going to want to do is use mkbundle to package your app together.  mkbundle will put your assembly, any dependent assemblies ( that can be known at compile time - dynamically loaded assemblies needed to be included in your .app, but I'll get to that later ), and a bootstrap entry point that allows your app to be executed independently of the mono executable.  ( Got that? It means that instead of saying "mono MyAssembly.exe", you'll just say "./MyAssembly", like you would with any other unix program )  At this stage, you can even include the mono runtime library as a static library, which would allow your app to run without linking to a pre-existing mono install ( for the most part - but I'll get to that ), but there are license issues with doing so, so let's avoid that.  ( I lost the link to that particular discussion, but the Mono runtime library is licensed with the LGPL, while the class library is licensed with the MIT X11 license.  The LGPL could be interpreted in such a way as to infer that your assembly, now bundled with the mono runtime, is now a derived work, and thus falls under more restrictive distribution rules.  Or something like that. ) Don't worry, though - we'll be including the mono runtime inside your app, and linking to it dynamically.  Because the executable will remain "physically separate" from the mono runtime lib, it won't be subject to the LGPL, and you won't end up in Guantanamo (unless you're already there, in which case, you shouldn't have copied that floppy, terrorist).

How do you use mkbundle?  Quite simply, actually:

Nant:
 <exec program="/sw/bin/mkbundle" commandline=" -o MyExec --deps ./bin/MyExec.exe" basedir="."/>

This will output the executable I mentioned above with the name "MyExec".

So far, great - if you run this app now, on your development machine, it should start up just fine.  But, that's just on your machine, and if you examine what libraries the executable depends on:

Command line:
 >otool -L myExec

You'll see that you have dylib dependencies to specific locations on your hard drive.  (Including the Mono runtime which is dynamically referenced because we didn't pass the --static flag to mkbundle, natch, or whatever makes me sound more well read) 

Also, you only have an executable! Not an .app file, which is really our concern, when it comes to distributing to OS X.  

So, let's create that app file.  You can do it the long way, but I suggest you cheat and just use macpack to create the structure for you.  

Nant:
 <exec program="/sw/bin/macpack" commandline="-n MyExec -o . -a ./bin/MyExec.exe -m cocoa -r ./MyExec"/>

Put short, this will create a directory named MyExec.app, copy your assembly MyExec.exe into it ( which you can delete after this is done - macpack just demands an assembly to copy ), create the requisite support files, and also put the executable we created with mkbundle in the directory MyExec.app/Contents/Resources.  We're going to leave it there, for reasons I'll get to later.

Now that we've created your folder, let's remove some of the junk we don't need:

 >rm MyExec.app/Contents/Resources/MyExec.exe
 >rm MyExec.app/Contents/MacOS/MyExec

All we've done is just get rid of the old assembly that macpack needed to run, and a shell script that macpack would have used to start that executable up with the installed mono runtime.  We'll replace that with our own shell script named MyExec, which looks like this:

 #!/bin/sh
 #butchered shell script from macpack
 PWD=`pwd`
 # Fetch the path relative to the launch point where this shell script exists.
 APP_PATH=`echo $0 | awk '{split($0,patharr,"/"); idx=1; while(patharr[idx+3] != "") { if (patharr[idx] != "/") {printf("%s/", patharr[idx]); idx++ }} }'`
 # Fetch the app name (its our own name)
 APP_NAME=`echo $0 | awk '{split($0,patharr,"/"); idx=1; while(patharr[idx+1] != "") {idx++} printf("%s", patharr[idx]); }'`
 
 # Setup the environment for Cocoa# if needed
 export MONO_GDIP_USE_COCOA_BACKEND=1
 cd "$APP_PATH/Contents/Resources"
 "./$APP_NAME"

As you can infer from the comments, this is just a hacked up version of the macpack shell script.  Because I'm a lazy bastard. All it does is just do a standard execution of your app from the Resources directory.  The reason we're leaving your executable in that directory is because (in my usage) you couldn't use the standard method of getting the codebase from the executing assembly to figure out what directory you're in, and then traversing back to the Resources directory to get any config / resource files your app needs.  So we're going to leave the entire "real" app in the Resources directory, and just use this shell script as a launcher.

Okay, so now we've got this pretty app file with your application in it, and if you dare to, you can double click on it and it will startup all Mac OS X'y ( alliteration! or something! ).  Problem:  there's no way it will run on any user's computer who doesn't have the libraries installed ( like the mono runtime library, glib, gmodule, gthread, etc. ) in the same paths as those output by otool.  How do we fix that?

Short answer: Use this Nant target, and replace the values in those properties at the top of it with whatever is appropriate for your app.
Less short answer that will make you wish you just used the short answer:  Get the otool output of your executable and each of the libraries that it references.  For any libraries that aren't part of a standard OS X install, copy it into MyExec.app/Contents/Frameworks ( the Apple defined location of included libraries with an app ), then use install_name_tool dash id to change the dynamic load id of each dylib, and install_name_tool dash change to change the referenced id's of each dylib, to an executable-relative path of the form:

 @executable_path/../Frameworks

Please note that when I say @executable_path, I LITERALLY MEAN @executable_path, and am not suddenly using an @ symbol to refer to something you yourself must change.

Short answer nant task:

	<target name="recursivelink">
		<property name="curfile" value="MyExec.app/Contents/Resources/MyExec"/>
		<property name="required_lib_prefix" value="/"/>
		<property name="lib_target" value="MyExec.app/Contents/Frameworks/"/>
		<property name="lib_rewrite_target" value="@executable_path/../Frameworks/"/>
		<mkdir dir="MyExec.app/Contents/Frameworks"/>
      <script language="C#">
          <code>
            <![CDATA[
			  public static string GetOtoolOutput(string lib){
				 System.Diagnostics.ProcessStartInfo psi = new System.Diagnostics.ProcessStartInfo("/usr/bin/otool", "-L "+lib);
				 psi.RedirectStandardOutput = true;
				 psi.UseShellExecute = false;
				 System.Diagnostics.Process p = System.Diagnostics.Process.Start(psi);
				 string tool_output = p.StandardOutput.ReadToEnd();
				 p.WaitForExit();
				 return tool_output;
		      }
			  public static void changeLibID(string newid,string target){
				 System.Diagnostics.ProcessStartInfo psi = 
 new System.Diagnostics.ProcessStartInfo("/usr/bin/install_name_tool", "-id "+newid+" "+target);
				 psi.UseShellExecute = false;
				 System.Diagnostics.Process p = System.Diagnostics.Process.Start(psi);
				 p.WaitForExit();
			  }
			  public static void changeLibRef(string oldlib,string newlib,string target){
				 System.Diagnostics.ProcessStartInfo psi = 
 new System.Diagnostics.ProcessStartInfo("/usr/bin/install_name_tool", "-change "+oldlib+" "+newlib+" "+target);
				 psi.UseShellExecute = false;
				 System.Diagnostics.Process p = System.Diagnostics.Process.Start(psi);
				 p.WaitForExit();
			  }
			  public static void IterateLibs(string file,Project project){
				System.Text.RegularExpressions.Regex reg = new System.Text.RegularExpressions.Regex(@"(?<path>\/[^\(\:]+)\(");
				System.Text.RegularExpressions.MatchCollection matches = reg.Matches(GetOtoolOutput(file));
				libs[file] = new Hashtable();
				foreach(System.Text.RegularExpressions.Match match in matches){
					string path = match.Groups["path"].Value;
					path = path.Trim();
					if(path.StartsWith(required_lib_prefix) && !excluded_libs.ContainsKey(Path.GetFileName(path))){
						((Hashtable)libs[file])[path] = true;
						if(!libs.ContainsKey(path))
							IterateLibs(path,project);
					}
				}
			  }
			  public static Hashtable libs;
			  public static Hashtable excluded_libs;
			  public static string required_lib_prefix;
			  public static string lib_target;
			  public static string lib_rewrite_target;
              public static void ScriptMain(Project project) {
					
					libs = new Hashtable();
					excluded_libs = new Hashtable();
					
					excluded_libs["CoreFoundation"] = true;
					excluded_libs["libgcc_s.1.dylib"] = true;
					excluded_libs["libSystem.B.dylib"] = true;
					//excluded_libs["libiconv.2.dylib"] = true;
					
					string startfile = project.Properties["curfile"];
					required_lib_prefix = project.Properties["required_lib_prefix"];
					lib_target = project.Properties["lib_target"];
					lib_rewrite_target = project.Properties["lib_rewrite_target"];
					IterateLibs(startfile,project);
					
					
					foreach(string s in libs.Keys){
						string newpath;
						if(s==startfile)
							newpath = s;
						else {
							string fname = Path.GetFileName(s);
							newpath = lib_target+fname;
							if(!File.Exists(newpath)){
								project.Log(Level.Info,"Copying "+s+" to "+newpath);
								File.Copy(s,newpath,true);
								changeLibID(lib_rewrite_target+fname,newpath);
							}
						}
					}
					foreach(string s in libs.Keys){
						string newpath;
						if(s==startfile)
							newpath = s;
						else 
							newpath = lib_target+Path.GetFileName(s);
						Hashtable thash = (Hashtable) libs[s];
						foreach(string t in thash.Keys){
							changeLibRef(t,lib_rewrite_target+Path.GetFileName(t),newpath);
						}
					}
					
					
					
					//project.Log(Level.Info,GetOtoolOutput(project.Properties["curfile"]));
					// Start the child process.
              }
            ]]>
          </code>
      </script>
	</target>

Just to reiterate, this will recursively copy all dylib (dynamic library) files that your application depends on (the dependencies of your dependencies, so to speak) to YourApp.app/Contents/Frameworks, and relink both your executable AND the dependent libraries to use a linking path relative to the location of the instantiating executing code.  The script maintains a registry of libs it /shouldn't/ link, which you can add to as necessary - you'll notice I commented out libiconv, because I'd rather distribute the version that Mono was linked against than rely on the user's machine.  

NOTE: Special note for people that installed Mono from the OS X DMG off the Mono site.  While I was making this script, I originally ran into a huge amount of problems reconciling the libs that fink had installed (in /sw/lib ) against the libs that were in the DMG installer ( in /Library/Frameworks/Mono.framework/Libraries ) - lots of complaints when executing about mismatched versions of libraries. I fixed it by just removing the Mono installed from DMG, and running sudo fink install mono.  Nothing feels better than avoiding dependency hell. 

Once you've used the above task to copy over the dependent lib files, you have ONE LAST thing to do, and that is copy over all dynamically loaded assemblies into MyExec.app/Contents/Resources .  You can't use mkbundle to include these assemblies, because Mono will be checking the filesystem for their existence.  And, if you're using Cocoa#, there's at least /ONE/ assembly that you MUST include in order for your application to work right: Mono.CompilerServices.SymbolWriter .  Cocoa# uses the ModuleBuilder class to emit a dynamically defined assembly, and that class dynamically loads Mono.CompilerServices.SymbolWriter - if you see a strange stacktrace from your application that mentions ModuleBuilder, chances are that your executable is not finding this assembly.  So:

Nant:
 		<copy todir="MyExec.app/Contents/Resources" overwrite="true">
			<fileset basedir="${framework::get-assembly-directory(framework::get-target-framework())}">
				<include name="Mono.CompilerServices.SymbolWriter*"/>
			</fileset>
		</copy>

And there you go! Redistributable app, ready to be deployed.    

Oh, and for bonus hacker points, you can use Jb Evain's linker.exe ( http://www.mono-project.com/Linker ) to compress down the size of your dependent classlibs to just the functions that your app uses.  Including all these libs is going to put a strain on your filesize.


